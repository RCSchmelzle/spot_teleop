cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/gen_xtion_cameras.py
#!/usr/bin/env python3
import os
import subprocess
import sys
from pathlib import Path

import yaml
from ament_index_python.packages import get_package_share_directory


def run_enumerator() -> list[str]:
    """
    Run the C++ xtion_enumerate tool and return the list of device URIs.
    Uses the OpenNI2 build living under cpp/OpenNI2.
    """
    enumerator_path = Path.home() / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi" / "xtion_enumerate"
    lib_dir = Path.home() / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"

    if not enumerator_path.exists():
        print(f"[gen_xtion_cameras] ERROR: {enumerator_path} not found. Did you build xtion_enumerate?", file=sys.stderr)
        sys.exit(1)

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(lib_dir) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        result = subprocess.run(
            [str(enumerator_path)],
            env=env,
            text=True,
            capture_output=True,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        print(f"[gen_xtion_cameras] ERROR running xtion_enumerate:", file=sys.stderr)
        print(e.stderr, file=sys.stderr)
        sys.exit(1)

    uris: list[str] = []
    for line in result.stdout.splitlines():
        line = line.strip()
        if not line:
            continue
        # Lines like: "URI:           1d27/0601@1/9"
        if line.startswith("URI:"):
            uri = line.split("URI:", 1)[1].strip()
            if uri:
                uris.append(uri)

    return uris


def load_mapping() -> dict[str, str]:
    """
    Load persistent mapping from URI -> role (logical name), if it exists.
    File format (xtion_mapping.yaml):

    mappings:
      - uri: "1d27/0601@1/9"
        role: "front_left"
      - uri: "1d27/0601@1/10"
        role: "front_right"
    """
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    mapping_path = share_dir / "config" / "xtion_mapping.yaml"

    if not mapping_path.exists():
        return {}

    try:
        with mapping_path.open("r") as f:
            data = yaml.safe_load(f) or {}
    except Exception as e:
        print(f"[gen_xtion_cameras] WARNING: Failed to read mapping file {mapping_path}: {e}", file=sys.stderr)
        return {}

    mappings_list = data.get("mappings", [])
    uri_to_role: dict[str, str] = {}
    for item in mappings_list:
        uri = item.get("uri")
        role = item.get("role")
        if uri and role:
            uri_to_role[uri] = role

    return uri_to_role


def write_yaml(uris: list[str]) -> Path:
    """
    Write xtion_cameras.yaml into xtion_bringup's share/config directory.
    Uses role mapping when available; falls back to cam0, cam1, ...
    """
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)

    yaml_path = config_dir / "xtion_cameras.yaml"

    if not uris:
        print("[gen_xtion_cameras] WARNING: No Xtion devices found. Writing empty cameras list.", file=sys.stderr)

    mapping = load_mapping()

    cameras = []
    for idx, uri in enumerate(uris):
        default_name = f"cam{idx}"
        name = mapping.get(uri, default_name)
        cameras.append(
            {
                "name": name,
                "namespace": name,
                "device_id": uri,
            }
        )

    data = {"cameras": cameras}

    with yaml_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)

    print(f"[gen_xtion_cameras] Wrote {yaml_path}")
    for cam in cameras:
        print(f"  - {cam['name']}: {cam['device_id']}")

    return yaml_path


def main():
    uris = run_enumerator()
    write_yaml(uris)


if __name__ == "__main__":
    main()
EOF




cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/xtion_mapper_gui.py
#!/usr/bin/env python3
import sys
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox

import yaml
from ament_index_python.packages import get_package_share_directory

from .gen_xtion_cameras import run_enumerator, load_mapping


def get_mapping_path() -> Path:
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    return config_dir / "xtion_mapping.yaml"


def save_mapping(uri_to_role: dict[str, str]) -> None:
    """
    Save mapping in the format:

    mappings:
      - uri: "1d27/0601@1/9"
        role: "front_left"
    """
    mapping_path = get_mapping_path()
    mappings_list = [
        {"uri": uri, "role": role}
        for uri, role in uri_to_role.items()
        if role.strip()
    ]

    data = {"mappings": mappings_list}

    with mapping_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)

    print(f"[xtion_mapper_gui] Wrote mapping file {mapping_path}")


def main():
    # Discover current devices
    uris = run_enumerator()
    if not uris:
        print("[xtion_mapper_gui] No devices found. Plug in Xtions and try again.", file=sys.stderr)
        messagebox.showerror("Xtion Mapper", "No Xtion devices found.\nPlug in cameras and try again.")
        return

    # Load existing mapping (URI -> role)
    existing_mapping = load_mapping()

    # Build initial roles per URI
    uri_roles: dict[str, str] = {}
    for idx, uri in enumerate(uris):
        default_role = f"cam{idx}"
        uri_roles[uri] = existing_mapping.get(uri, default_role)

    # Pre-populate list of suggested role names
    suggested_roles = set(existing_mapping.values()) | set(uri_roles.values())
    suggested_roles |= {"front_left", "front_right", "overhead", "hand", "unused"}
    role_options = sorted(suggested_roles)

    # --- Build GUI ---
    root = tk.Tk()
    root.title("Xtion Camera Role Mapper")

    main_frame = ttk.Frame(root, padding=10)
    main_frame.grid(row=0, column=0, sticky="nsew")

    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)

    # Header
    ttk.Label(main_frame, text="URI", font=("TkDefaultFont", 10, "bold")).grid(row=0, column=0, sticky="w", padx=5, pady=5)
    ttk.Label(main_frame, text="Role / Name", font=("TkDefaultFont", 10, "bold")).grid(row=0, column=1, sticky="w", padx=5, pady=5)

    # Rows: one per URI
    row_widgets = []
    for row_idx, uri in enumerate(uris, start=1):
        ttk.Label(main_frame, text=uri).grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)

        var = tk.StringVar(value=uri_roles[uri])
        combo = ttk.Combobox(main_frame, textvariable=var, values=role_options)
        combo.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        combo.configure(state="normal")  # allow typing custom role
        row_widgets.append((uri, var))

    def on_save():
        updated_mapping: dict[str, str] = {}
        for uri, var in row_widgets:
            role = var.get().strip()
            if role:
                updated_mapping[uri] = role

        if not updated_mapping:
            if not messagebox.askyesno(
                "Confirm",
                "No roles specified. This will clear the mapping file.\nContinue?"
            ):
                return

        try:
            save_mapping(updated_mapping)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save mapping:\n{e}")
            return

        messagebox.showinfo(
            "Saved",
            "Mapping saved.\n\nNow re-run:\n  python3 -m xtion_bringup.gen_xtion_cameras\nbefore launching multi_xtion."
        )
        root.destroy()

    # Buttons
    button_frame = ttk.Frame(main_frame)
    button_frame.grid(row=len(uris) + 1, column=0, columnspan=2, sticky="e", pady=(10, 0))

    save_btn = ttk.Button(button_frame, text="Save & Close", command=on_save)
    save_btn.grid(row=0, column=0, padx=5)

    cancel_btn = ttk.Button(button_frame, text="Cancel", command=root.destroy)
    cancel_btn.grid(row=0, column=1, padx=5)

    root.mainloop()


if __name__ == "__main__":
    main()
EOF


sudo apt install python3-tk
ros2 run xtion_bringup xtion_mapper_gui



cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/gen_xtion_cameras.py
#!/usr/bin/env python3
import os
import subprocess
import sys
from pathlib import Path

import yaml
from ament_index_python.packages import get_package_share_directory


def run_enumerator() -> list[str]:
    """
    Run the C++ xtion_enumerate tool and return the list of device URIs.
    Uses the OpenNI2 build living under cpp/OpenNI2.
    """
    enumerator_path = Path.home() / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi" / "xtion_enumerate"
    lib_dir = Path.home() / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"

    if not enumerator_path.exists():
        print(f"[gen_xtion_cameras] ERROR: {enumerator_path} not found. Did you build xtion_enumerate?", file=sys.stderr)
        sys.exit(1)

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(lib_dir) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        result = subprocess.run(
            [str(enumerator_path)],
            env=env,
            text=True,
            capture_output=True,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        print(f"[gen_xtion_cameras] ERROR running xtion_enumerate:", file=sys.stderr)
        print(e.stderr, file=sys.stderr)
        sys.exit(1)

    uris: list[str] = []
    for line in result.stdout.splitlines():
        line = line.strip()
        if not line:
            continue
        # Lines like: "URI:           1d27/0601@1/9"
        if line.startswith("URI:"):
            uri = line.split("URI:", 1)[1].strip()
            if uri:
                uris.append(uri)

    return uris


def load_mapping() -> dict[str, str]:
    """
    Load persistent mapping from URI -> role (logical name), if it exists.
    File format (xtion_mapping.yaml):

    mappings:
      - uri: "1d27/0601@1/9"
        role: "front_left"
      - uri: "1d27/0601@1/10"
        role: "front_right"
    """
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    mapping_path = share_dir / "config" / "xtion_mapping.yaml"

    if not mapping_path.exists():
        return {}

    try:
        with mapping_path.open("r") as f:
            data = yaml.safe_load(f) or {}
    except Exception as e:
        print(f"[gen_xtion_cameras] WARNING: Failed to read mapping file {mapping_path}: {e}", file=sys.stderr)
        return {}

    mappings_list = data.get("mappings", [])
    uri_to_role: dict[str, str] = {}
    for item in mappings_list:
        uri = item.get("uri")
        role = item.get("role")
        if uri and role:
            uri_to_role[uri] = role

    return uri_to_role


def write_yaml(uris: list[str]) -> Path:
    """
    Write xtion_cameras.yaml into xtion_bringup's share/config directory.
    Uses role mapping when available; falls back to cam0, cam1, ...
    """
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)

    yaml_path = config_dir / "xtion_cameras.yaml"

    if not uris:
        print("[gen_xtion_cameras] WARNING: No Xtion devices found. Writing empty cameras list.", file=sys.stderr)

    mapping = load_mapping()

    cameras = []
    for idx, uri in enumerate(uris):
        default_name = f"cam{idx}"
        name = mapping.get(uri, default_name)
        cameras.append(
            {
                "name": name,
                "namespace": name,
                "device_id": uri,
            }
        )

    data = {"cameras": cameras}

    with yaml_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)

    print(f"[gen_xtion_cameras] Wrote {yaml_path}")
    for cam in cameras:
        print(f"  - {cam['name']}: {cam['device_id']}")

    return yaml_path


def main():
    uris = run_enumerator()
    write_yaml(uris)


if __name__ == "__main__":
    main()
EOF



cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/xtion_mapper_gui.py
#!/usr/bin/env python3
import sys
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox

import yaml
from ament_index_python.packages import get_package_share_directory

from .gen_xtion_cameras import run_enumerator, load_mapping


def get_mapping_path() -> Path:
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    return config_dir / "xtion_mapping.yaml"


def save_mapping(uri_to_role: dict[str, str]) -> None:
    """
    Save mapping in the format:

    mappings:
      - uri: "1d27/0601@1/9"
        role: "front_left"
    """
    mapping_path = get_mapping_path()
    mappings_list = [
        {"uri": uri, "role": role}
        for uri, role in uri_to_role.items()
        if role.strip()
    ]

    data = {"mappings": mappings_list}

    with mapping_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)

    print(f"[xtion_mapper_gui] Wrote mapping file {mapping_path}")


def main():
    # Discover current devices
    uris = run_enumerator()
    if not uris:
        print("[xtion_mapper_gui] No devices found. Plug in Xtions and try again.", file=sys.stderr)
        messagebox.showerror("Xtion Mapper", "No Xtion devices found.\nPlug in cameras and try again.")
        return

    # Load existing mapping (URI -> role)
    existing_mapping = load_mapping()

    # Build initial roles per URI
    uri_roles: dict[str, str] = {}
    for idx, uri in enumerate(uris):
        default_role = f"cam{idx}"
        uri_roles[uri] = existing_mapping.get(uri, default_role)

    # Pre-populate list of suggested role names
    suggested_roles = set(existing_mapping.values()) | set(uri_roles.values())
    suggested_roles |= {"front_left", "front_right", "overhead", "hand", "unused"}
    role_options = sorted(suggested_roles)

    # --- Build GUI ---
    root = tk.Tk()
    root.title("Xtion Camera Role Mapper")

    main_frame = ttk.Frame(root, padding=10)
    main_frame.grid(row=0, column=0, sticky="nsew")

    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)

    # Header
    ttk.Label(main_frame, text="URI", font=("TkDefaultFont", 10, "bold")).grid(row=0, column=0, sticky="w", padx=5, pady=5)
    ttk.Label(main_frame, text="Role / Name", font=("TkDefaultFont", 10, "bold")).grid(row=0, column=1, sticky="w", padx=5, pady=5)

    # Rows: one per URI
    row_widgets = []
    for row_idx, uri in enumerate(uris, start=1):
        ttk.Label(main_frame, text=uri).grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)

        var = tk.StringVar(value=uri_roles[uri])
        combo = ttk.Combobox(main_frame, textvariable=var, values=role_options)
        combo.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        combo.configure(state="normal")  # allow typing custom role
        row_widgets.append((uri, var))

    def on_save():
        updated_mapping: dict[str, str] = {}
        for uri, var in row_widgets:
            role = var.get().strip()
            if role:
                updated_mapping[uri] = role

        if not updated_mapping:
            if not messagebox.askyesno(
                "Confirm",
                "No roles specified. This will clear the mapping file.\nContinue?"
            ):
                return

        try:
            save_mapping(updated_mapping)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save mapping:\n{e}")
            return

        messagebox.showinfo(
            "Saved",
            "Mapping saved.\n\nNow re-run:\n  python3 -m xtion_bringup.gen_xtion_cameras\nbefore launching multi_xtion."
        )
        root.destroy()

    # Buttons
    button_frame = ttk.Frame(main_frame)
    button_frame.grid(row=len(uris) + 1, column=0, columnspan=2, sticky="e", pady=(10, 0))

    save_btn = ttk.Button(button_frame, text="Save & Close", command=on_save)
    save_btn.grid(row=0, column=0, padx=5)

    cancel_btn = ttk.Button(button_frame, text="Cancel", command=root.destroy)
    cancel_btn.grid(row=0, column=1, padx=5)

    root.mainloop()


if __name__ == "__main__":
    main()
EOF



cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/setup.py
from setuptools import setup

package_name = 'xtion_bringup'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages', ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        ('share/' + package_name + '/launch', [
            'launch/multi_xtion.launch.py',
        ]),
        ('share/' + package_name + '/config', [
            'config/xtion_cameras.yaml',
        ]),
    ],
    install_requires=['setuptools', 'PyYAML'],
    zip_safe=True,
    maintainer='teleop',
    maintainer_email='you@example.com',
    description='Bringup utilities for ASUS Xtion cameras',
    license='MIT',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'gen_xtion_cameras = xtion_bringup.gen_xtion_cameras:main',
            'xtion_mapper_gui = xtion_bringup.xtion_mapper_gui:main',
        ],
    },
)
EOF


touch ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/__init__.py


cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash

colcon build --packages-select xtion_bringup
source install/setup.bash


python3 -m xtion_bringup.xtion_mapper_gui
python3 -m xtion_bringup.gen_xtion_cameras
cat install/xtion_bringup/share/xtion_bringup/config/xtion_cameras.yaml


sudo apt install python3-pil


cd ~/Projects/teleoperation_spot/cpp/xtion_multi

cat << 'EOF' > ~/Projects/teleoperation_spot/cpp/xtion_multi/xtion_snapshot.cpp
#include <OpenNI.h>
#include <iostream>

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Usage: xtion_snapshot <device_uri>" << std::endl;
        return 1;
    }

    const char* uri = argv[1];

    // Initialize OpenNI
    openni::Status rc = openni::OpenNI::initialize();
    if (rc != openni::STATUS_OK) {
        std::cerr << "Initialize failed:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        return 1;
    }

    // Open device
    openni::Device device;
    rc = device.open(uri);
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to open device " << uri << ":\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        openni::OpenNI::shutdown();
        return 1;
    }

    // Create color stream
    openni::VideoStream color;
    rc = color.create(device, openni::SENSOR_COLOR);
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to create color stream:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    rc = color.start();
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to start color stream:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    // Read a single frame
    openni::VideoFrameRef frame;
    rc = color.readFrame(&frame);
    if (rc != openni::STATUS_OK || !frame.isValid()) {
        std::cerr << "Failed to read color frame:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        color.stop();
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    if (frame.getVideoMode().getPixelFormat() != openni::PIXEL_FORMAT_RGB888) {
        std::cerr << "Unexpected pixel format, expected RGB888" << std::endl;
        color.stop();
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    int width = frame.getWidth();
    int height = frame.getHeight();
    int dataSize = frame.getDataSize();

    // Output PPM (P6) to stdout
    std::cout << "P6\n" << width << " " << height << "\n255\n";
    std::cout.write(static_cast<const char*>(frame.getData()), dataSize);
    std::cout.flush();

    // Cleanup
    color.stop();
    color.destroy();
    device.close();
    openni::OpenNI::shutdown();

    return 0;
}
EOF


cd ~/Projects/teleoperation_spot/cpp/xtion_multi

g++ xtion_snapshot.cpp \
  -o xtion_snapshot \
  -I/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Include \
  -L/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  -lOpenNI2


LD_LIBRARY_PATH=/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  ./xtion_snapshot 1d27/0601@1/9 > /tmp/xtion_test.ppm


cat << 'EOF' > ~/Projects/teleoperation_spot/cpp/xtion_multi/xtion_snapshot.cpp
#include <OpenNI.h>
#include <iostream>
#include <cstdint>

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Usage: xtion_snapshot <device_uri>" << std::endl;
        return 1;
    }

    const char* uri = argv[1];

    // Initialize OpenNI
    openni::Status rc = openni::OpenNI::initialize();
    if (rc != openni::STATUS_OK) {
        std::cerr << "Initialize failed:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        return 1;
    }

    // Open device
    openni::Device device;
    rc = device.open(uri);
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to open device " << uri << ":\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        openni::OpenNI::shutdown();
        return 1;
    }

    // Create color stream
    openni::VideoStream color;
    rc = color.create(device, openni::SENSOR_COLOR);
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to create color stream:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    rc = color.start();
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to start color stream:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    // Read a few frames to let auto exposure settle
    openni::VideoFrameRef frame;
    for (int i = 0; i < 5; ++i) {
        rc = color.readFrame(&frame);
        if (rc != openni::STATUS_OK) {
            std::cerr << "Failed to read color frame:\n"
                      << openni::OpenNI::getExtendedError() << std::endl;
            color.stop();
            color.destroy();
            device.close();
            openni::OpenNI::shutdown();
            return 1;
        }
        if (frame.isValid()) break;
    }

    if (!frame.isValid()) {
        std::cerr << "No valid color frame received." << std::endl;
        color.stop();
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    if (frame.getVideoMode().getPixelFormat() != openni::PIXEL_FORMAT_RGB888) {
        std::cerr << "Unexpected pixel format, expected RGB888" << std::endl;
        color.stop();
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    int width = frame.getWidth();
    int height = frame.getHeight();
    const std::uint8_t* data = static_cast<const std::uint8_t*>(frame.getData());
    int expected_size = width * height * 3;

    // Emit PPM header
    std::cout << "P6\n" << width << " " << height << "\n255\n";
    // Emit pixel data
    std::cout.write(reinterpret_cast<const char*>(data), expected_size);
    std::cout.flush();

    // Cleanup
    color.stop();
    color.destroy();
    device.close();
    openni::OpenNI::shutdown();

    return 0;
}
EOF



cd ~/Projects/teleoperation_spot/cpp/xtion_multi

g++ xtion_snapshot.cpp \
  -o xtion_snapshot \
  -I/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Include \
  -L/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  -lOpenNI2


head -5 /tmp/xtion_test.ppm




cat << 'EOF' > ~/Projects/teleoperation_spot/cpp/xtion_multi/xtion_snapshot.cpp
#include <OpenNI.h>
#include <iostream>
#include <fstream>
#include <cstdint>

int main(int argc, char** argv) {
    if (argc < 3) {
        std::cerr << "Usage: xtion_snapshot <device_uri> <output_ppm_path>" << std::endl;
        return 1;
    }

    const char* uri = argv[1];
    const char* out_path = argv[2];

    // Initialize OpenNI
    openni::Status rc = openni::OpenNI::initialize();
    if (rc != openni::STATUS_OK) {
        std::cerr << "Initialize failed:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        return 1;
    }

    // Open device
    openni::Device device;
    rc = device.open(uri);
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to open device " << uri << ":\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        openni::OpenNI::shutdown();
        return 1;
    }

    // Create color stream
    openni::VideoStream color;
    rc = color.create(device, openni::SENSOR_COLOR);
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to create color stream:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    rc = color.start();
    if (rc != openni::STATUS_OK) {
        std::cerr << "Failed to start color stream:\n"
                  << openni::OpenNI::getExtendedError() << std::endl;
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    // Read a few frames to let exposure settle
    openni::VideoFrameRef frame;
    for (int i = 0; i < 5; ++i) {
        rc = color.readFrame(&frame);
        if (rc != openni::STATUS_OK) {
            continue;
        }
        if (frame.isValid()) break;
    }

    if (!frame.isValid()) {
        std::cerr << "No valid color frame received." << std::endl;
        color.stop();
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    if (frame.getVideoMode().getPixelFormat() != openni::PIXEL_FORMAT_RGB888) {
        std::cerr << "Unexpected pixel format, expected RGB888" << std::endl;
        color.stop();
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    int width = frame.getWidth();
    int height = frame.getHeight();
    const std::uint8_t* data = static_cast<const std::uint8_t*>(frame.getData());
    int expected_size = width * height * 3;

    std::ofstream ofs(out_path, std::ios::binary);
    if (!ofs) {
        std::cerr << "Failed to open output file: " << out_path << std::endl;
        color.stop();
        color.destroy();
        device.close();
        openni::OpenNI::shutdown();
        return 1;
    }

    // Write PPM header
    ofs << "P6\n" << width << " " << height << "\n255\n";
    // Write pixel data
    ofs.write(reinterpret_cast<const char*>(data), expected_size);
    ofs.close();

    // Cleanup
    color.stop();
    color.destroy();
    device.close();
    openni::OpenNI::shutdown();

    return 0;
}
EOF


cd ~/Projects/teleoperation_spot/cpp/xtion_multi

g++ xtion_snapshot.cpp \
  -o xtion_snapshot \
  -I/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Include \
  -L/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  -lOpenNI2



LD_LIBRARY_PATH=/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  ./xtion_snapshot 1d27/0601@1/9 /tmp/xtion_test.ppm


head -5 /tmp/xtion_test.ppm
file /tmp/xtion_test.ppm


cat << 'EOF' > /tmp/_capture_preview_patch.py
import os
from pathlib import Path
from PIL import Image

HOME = Path.home()
XTION_MULTI_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi"
SNAPSHOT_BIN = XTION_MULTI_DIR / "xtion_snapshot"
OPENNI_LIB_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"

def capture_preview(uri: str) -> Image.Image | None:
    """
    Run the C++ xtion_snapshot tool for a given URI and return a PIL Image.
    xtion_snapshot writes a PPM file to disk; we load that.
    """
    import subprocess
    import traceback

    if not SNAPSHOT_BIN.exists():
        print(f"[xtion_mapper_gui] Snapshot binary not found: {SNAPSHOT_BIN}", file=sys.stderr)
        return None

    # Per-URI temp file (e.g. ~/.cache/xtion_previews/1d27_0601_1_9.ppm)
    cache_dir = HOME / ".cache" / "xtion_previews"
    cache_dir.mkdir(parents=True, exist_ok=True)
    safe_uri = uri.replace("/", "_").replace("@", "_")
    ppm_path = cache_dir / f"{safe_uri}.ppm"

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(OPENNI_LIB_DIR) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        subprocess.run(
            [str(SNAPSHOT_BIN), uri, str(ppm_path)],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
    except subprocess.CalledProcessError:
        print(f"[xtion_mapper_gui] Snapshot failed for {uri}", file=sys.stderr)
        return None
    except Exception:
        traceback.print_exc()
        return None

    if not ppm_path.exists():
        return None

    try:
        img = Image.open(ppm_path)
        img = img.convert("RGB")
        img.thumbnail((240, 180))
        return img
    except Exception as e:
        print(f"[xtion_mapper_gui] Failed to decode snapshot for {uri}: {e}", file=sys.stderr)
        return None
EOF

cat << 'EOF' > /tmp/_capture_preview_patch.py
import os
from pathlib import Path
from PIL import Image

HOME = Path.home()
XTION_MULTI_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi"
SNAPSHOT_BIN = XTION_MULTI_DIR / "xtion_snapshot"
OPENNI_LIB_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"

def capture_preview(uri: str) -> Image.Image | None:
    """
    Run the C++ xtion_snapshot tool for a given URI and return a PIL Image.
    xtion_snapshot writes a PPM file to disk; we load that.
    """
    import subprocess
    import traceback

    if not SNAPSHOT_BIN.exists():
        print(f"[xtion_mapper_gui] Snapshot binary not found: {SNAPSHOT_BIN}", file=sys.stderr)
        return None

    # Per-URI temp file (e.g. ~/.cache/xtion_previews/1d27_0601_1_9.ppm)
    cache_dir = HOME / ".cache" / "xtion_previews"
    cache_dir.mkdir(parents=True, exist_ok=True)
    safe_uri = uri.replace("/", "_").replace("@", "_")
    ppm_path = cache_dir / f"{safe_uri}.ppm"

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(OPENNI_LIB_DIR) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        subprocess.run(
            [str(SNAPSHOT_BIN), uri, str(ppm_path)],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
    except subprocess.CalledProcessError:
        print(f"[xtion_mapper_gui] Snapshot failed for {uri}", file=sys.stderr)
        return None
    except Exception:
        traceback.print_exc()
        return None

    if not ppm_path.exists():
        return None

    try:
        img = Image.open(ppm_path)
        img = img.convert("RGB")
        img.thumbnail((240, 180))
        return img
    except Exception as e:
        print(f"[xtion_mapper_gui] Failed to decode snapshot for {uri}: {e}", file=sys.stderr)
        return None
EOF




cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/xtion_mapper_gui.py
#!/usr/bin/env python3
import os
import sys
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox

import yaml
from PIL import Image, ImageTk
from ament_index_python.packages import get_package_share_directory

from .gen_xtion_cameras import run_enumerator, load_mapping

HOME = Path.home()
XTION_MULTI_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi"
SNAPSHOT_BIN = XTION_MULTI_DIR / "xtion_snapshot"
OPENNI_LIB_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"


def get_mapping_path() -> Path:
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    return config_dir / "xtion_mapping.yaml"


def save_mapping(uri_to_role: dict[str, str]) -> None:
    mappings_list = [
        {"uri": uri, "role": role}
        for uri, role in uri_to_role.items()
        if role.strip()
    ]
    mapping_path = get_mapping_path()
    data = {"mappings": mappings_list}
    with mapping_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)
    print(f"[xtion_mapper_gui] Wrote mapping file {mapping_path}")


def capture_preview(uri: str) -> Image.Image | None:
    """
    Run the C++ xtion_snapshot tool for a given URI and return a PIL Image.
    xtion_snapshot writes a PPM file to disk; we load that.
    """
    import subprocess
    import traceback

    if not SNAPSHOT_BIN.exists():
        print(f"[xtion_mapper_gui] Snapshot binary not found: {SNAPSHOT_BIN}", file=sys.stderr)
        return None

    cache_dir = HOME / ".cache" / "xtion_previews"
    cache_dir.mkdir(parents=True, exist_ok=True)
    safe_uri = uri.replace("/", "_").replace("@", "_")
    ppm_path = cache_dir / f"{safe_uri}.ppm"

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(OPENNI_LIB_DIR) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        subprocess.run(
            [str(SNAPSHOT_BIN), uri, str(ppm_path)],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
    except subprocess.CalledProcessError:
        print(f"[xtion_mapper_gui] Snapshot failed for {uri}", file=sys.stderr)
        return None
    except Exception:
        traceback.print_exc()
        return None

    if not ppm_path.exists():
        return None

    try:
        img = Image.open(ppm_path)
        img = img.convert("RGB")
        img.thumbnail((240, 180))
        return img
    except Exception as e:
        print(f"[xtion_mapper_gui] Failed to decode snapshot for {uri}: {e}", file=sys.stderr)
        return None


def main():
    # Discover current devices
    uris = run_enumerator()
    if not uris:
        print("[xtion_mapper_gui] No devices found. Plug in Xtions and try again.", file=sys.stderr)
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Xtion Mapper", "No Xtion devices found.\nPlug in cameras and try again.")
        root.destroy()
        return

    existing_mapping = load_mapping()

    uri_roles: dict[str, str] = {}
    for idx, uri in enumerate(uris):
        default_role = f"cam{idx}"
        uri_roles[uri] = existing_mapping.get(uri, default_role)

    suggested_roles = set(existing_mapping.values()) | set(uri_roles.values())
    suggested_roles |= {"front_left", "front_right", "overhead", "hand", "unused"}
    role_options = sorted(suggested_roles)

    root = tk.Tk()
    root.title("Xtion Camera Role Mapper")

    main_frame = ttk.Frame(root, padding=10)
    main_frame.grid(row=0, column=0, sticky="nsew")

    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.columnconfigure(2, weight=1)

    ttk.Label(main_frame, text="URI", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=0, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Role / Name", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=1, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Preview", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=2, sticky="w", padx=5, pady=5
    )

    row_widgets = []  # (uri, role_var, preview_label)
    for row_idx, uri in enumerate(uris, start=1):
        ttk.Label(main_frame, text=uri).grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)

        var = tk.StringVar(value=uri_roles[uri])
        combo = ttk.Combobox(main_frame, textvariable=var, values=role_options)
        combo.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        combo.configure(state="normal")

        preview_label = ttk.Label(main_frame, text="(preview)")
        preview_label.grid(row=row_idx, column=2, sticky="w", padx=5, pady=2)

        row_widgets.append((uri, var, preview_label))

    def on_save():
        updated_mapping: dict[str, str] = {}
        for uri, var, _label in row_widgets:
            role = var.get().strip()
            if role:
                updated_mapping[uri] = role

        if not updated_mapping:
            if not messagebox.askyesno(
                "Confirm",
                "No roles specified. This will clear the mapping file.\nContinue?"
            ):
                return

        try:
            save_mapping(updated_mapping)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save mapping:\n{e}")
            return

        messagebox.showinfo(
            "Saved",
            "Mapping saved.\n\nNow re-run:\n  python3 -m xtion_bringup.gen_xtion_cameras\nbefore launching multi_xtion."
        )
        root.destroy()

    button_frame = ttk.Frame(main_frame)
    button_frame.grid(row=len(uris) + 1, column=0, columnspan=3, sticky="e", pady=(10, 0))

    save_btn = ttk.Button(button_frame, text="Save & Close", command=on_save)
    save_btn.grid(row=0, column=0, padx=5)

    cancel_btn = ttk.Button(button_frame, text="Cancel", command=root.destroy)
    cancel_btn.grid(row=0, column=1, padx=5)

    def update_previews():
        for uri, _var, label in row_widgets:
            img = capture_preview(uri)
            if img is None:
                continue
            photo = ImageTk.PhotoImage(img)
            label.configure(image=photo, text="")
            label.image = photo
        root.after(500, update_previews)

    root.after(500, update_previews)
    root.mainloop()


if __name__ == "__main__":
    main()
EOF


cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash
source install/setup.bash

python3 -m xtion_bringup.xtion_mapper_gui

cd ~/Projects/teleoperation_spot/system_ws
  source /opt/ros/jazzy/setup.bash
  colcon build --packages-select xtion_bringup
  source install/setup.bash


  python3 -m xtion_bringup.xtion_mapper_gui



 cd ~/Projects/teleoperation_spot/system_ws
  source /opt/ros/jazzy/setup.bash
  colcon build --packages-select xtion_bringup
  source install/setup.bash
  2. Then run the GUI again:
  python3 -m xtion_bringup.xtion_mapper_gui


swap 500 for 100 in the mapper gui code


cd ~/Projects/teleoperation_spot/cpp/xtion_multi

g++ xtion_snapshot.cpp \
  -o xtion_snapshot \
  -I/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Include \
  -L/home/rysch01/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  -lOpenNI2


cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash
source install/setup.bash

python3 -m xtion_bringup.xtion_mapper_gui
python3 -m xtion_bringup.gen_xtion_cameras
cat install/xtion_bringup/share/xtion_bringup/config/xtion_cameras.yaml
ros2 launch xtion_bringup multi_xtion.launch.py



cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/xtion_mapper_gui.py
#!/usr/bin/env python3
import os
import sys
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox

import yaml
from PIL import Image, ImageTk
from ament_index_python.packages import get_package_share_directory

from .gen_xtion_cameras import run_enumerator, load_mapping

HOME = Path.home()
XTION_MULTI_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi"
SNAPSHOT_BIN = XTION_MULTI_DIR / "xtion_snapshot"
OPENNI_LIB_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"


def get_mapping_path() -> Path:
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    return config_dir / "xtion_mapping.yaml"


def save_mapping(uri_to_role: dict[str, str]) -> None:
    mappings_list = [
        {"uri": uri, "role": role}
        for uri, role in uri_to_role.items()
        if role.strip()
    ]
    mapping_path = get_mapping_path()
    data = {"mappings": mappings_list}
    with mapping_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)
    print(f"[xtion_mapper_gui] Wrote mapping file {mapping_path}")


def capture_preview(uri: str) -> Image.Image | None:
    """
    Run the C++ xtion_snapshot tool for a given URI and return a PIL Image.
    xtion_snapshot writes a PPM file to disk; we load that.
    """
    import subprocess
    import traceback

    if not SNAPSHOT_BIN.exists():
        print(f"[xtion_mapper_gui] Snapshot binary not found: {SNAPSHOT_BIN}", file=sys.stderr)
        return None

    cache_dir = HOME / ".cache" / "xtion_previews"
    cache_dir.mkdir(parents=True, exist_ok=True)
    safe_uri = uri.replace("/", "_").replace("@", "_")
    ppm_path = cache_dir / f"{safe_uri}.ppm"

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(OPENNI_LIB_DIR) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        subprocess.run(
            [str(SNAPSHOT_BIN), uri, str(ppm_path)],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
    except subprocess.CalledProcessError:
        print(f"[xtion_mapper_gui] Snapshot failed for {uri}", file=sys.stderr)
        return None
    except Exception:
        traceback.print_exc()
        return None

    if not ppm_path.exists():
        return None

    try:
        img = Image.open(ppm_path)
        img = img.convert("RGB")
        img.thumbnail((240, 180))
        return img
    except Exception as e:
        print(f"[xtion_mapper_gui] Failed to decode snapshot for {uri}: {e}", file=sys.stderr)
        return None


def main():
    # Discover current devices
    uris = run_enumerator()
    if not uris:
        print("[xtion_mapper_gui] No devices found. Plug in Xtions and try again.", file=sys.stderr)
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Xtion Mapper", "No Xtion devices found.\nPlug in cameras and try again.")
        root.destroy()
        return

    existing_mapping = load_mapping()

    uri_roles: dict[str, str] = {}
    for idx, uri in enumerate(uris):
        default_role = f"cam{idx}"
        uri_roles[uri] = existing_mapping.get(uri, default_role)

    suggested_roles = set(existing_mapping.values()) | set(uri_roles.values())
    suggested_roles |= {"front_left", "front_right", "overhead", "hand", "unused"}
    role_options = sorted(suggested_roles)

    root = tk.Tk()
    root.title("Xtion Camera Role Mapper")

    main_frame = ttk.Frame(root, padding=10)
    main_frame.grid(row=0, column=0, sticky="nsew")

    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.columnconfigure(2, weight=1)

    ttk.Label(main_frame, text="URI", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=0, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Role / Name", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=1, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Preview", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=2, sticky="w", padx=5, pady=5
    )

    row_widgets = []  # (uri, role_var, preview_label)
    for row_idx, uri in enumerate(uris, start=1):
        ttk.Label(main_frame, text=uri).grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)

        var = tk.StringVar(value=uri_roles[uri])
        combo = ttk.Combobox(main_frame, textvariable=var, values=role_options)
        combo.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        combo.configure(state="normal")

        preview_label = ttk.Label(main_frame, text="(click Refresh)")
        preview_label.grid(row=row_idx, column=2, sticky="w", padx=5, pady=2)

        row_widgets.append((uri, var, preview_label))

    def update_previews_once():
        for uri, _var, label in row_widgets:
            img = capture_preview(uri)
            if img is None:
                continue
            photo = ImageTk.PhotoImage(img)
            label.configure(image=photo, text="")
            label.image = photo  # keep reference

    def on_save():
        updated_mapping: dict[str, str] = {}
        for uri, var, _label in row_widgets:
            role = var.get().strip()
            if role:
                updated_mapping[uri] = role

        if not updated_mapping:
            if not messagebox.askyesno(
                "Confirm",
                "No roles specified. This will clear the mapping file.\nContinue?"
            ):
                return

        try:
            save_mapping(updated_mapping)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save mapping:\n{e}")
            return

        messagebox.showinfo(
            "Saved",
            "Mapping saved.\n\nNow re-run:\n  python3 -m xtion_bringup.gen_xtion_cameras\nbefore launching multi_xtion."
        )
        root.destroy()

    # Buttons
    button_frame = ttk.Frame(main_frame)
    button_frame.grid(row=len(uris) + 1, column=0, columnspan=3, sticky="e", pady=(10, 0))

    refresh_btn = ttk.Button(button_frame, text="Refresh previews", command=update_previews_once)
    refresh_btn.grid(row=0, column=0, padx=5)

    save_btn = ttk.Button(button_frame, text="Save & Close", command=on_save)
    save_btn.grid(row=0, column=1, padx=5)

    cancel_btn = ttk.Button(button_frame, text="Cancel", command=root.destroy)
    cancel_btn.grid(row=0, column=2, padx=5)

    # Grab one set of previews at startup
    update_previews_once()

    root.mainloop()


if __name__ == "__main__":
    main()
EOF





cd ~/Projects/teleoperation_spot/cpp/xtion_multi
LD_LIBRARY_PATH=~/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  ./xtion_snapshot 1d27/0601@1/9 /tmp/xtion_test.ppm


cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash
source install/setup.bash

python3 -m xtion_bringup.xtion_mapper_gui



cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/xtion_mapper_gui.py
#!/usr/bin/env python3
import os
import sys
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox

import yaml
from PIL import Image, ImageTk
from ament_index_python.packages import get_package_share_directory

from .gen_xtion_cameras import run_enumerator, load_mapping

HOME = Path.home()
XTION_MULTI_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi"
SNAPSHOT_BIN = XTION_MULTI_DIR / "xtion_snapshot"
OPENNI_LIB_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"


def get_mapping_path() -> Path:
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    return config_dir / "xtion_mapping.yaml"


def save_mapping(uri_to_role: dict[str, str]) -> None:
    mappings_list = [
        {"uri": uri, "role": role}
        for uri, role in uri_to_role.items()
        if role.strip()
    ]
    mapping_path = get_mapping_path()
    data = {"mappings": mappings_list}
    with mapping_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)
    print(f"[xtion_mapper_gui] Wrote mapping file {mapping_path}")


def capture_preview(uri: str) -> Image.Image | None:
    """
    Run the C++ xtion_snapshot tool for a given URI and return a PIL Image.
    xtion_snapshot writes a PPM file to disk; we load that.
    """
    import subprocess
    import traceback

    if not SNAPSHOT_BIN.exists():
        print(f"[xtion_mapper_gui] Snapshot binary not found: {SNAPSHOT_BIN}", file=sys.stderr)
        return None

    cache_dir = HOME / ".cache" / "xtion_previews"
    cache_dir.mkdir(parents=True, exist_ok=True)
    safe_uri = uri.replace("/", "_").replace("@", "_")
    ppm_path = cache_dir / f"{safe_uri}.ppm"

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(OPENNI_LIB_DIR) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        subprocess.run(
            [str(SNAPSHOT_BIN), uri, str(ppm_path)],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
    except subprocess.CalledProcessError:
        print(f"[xtion_mapper_gui] Snapshot failed for {uri}", file=sys.stderr)
        return None
    except Exception:
        traceback.print_exc()
        return None

    if not ppm_path.exists():
        return None

    try:
        img = Image.open(ppm_path)
        img = img.convert("RGB")
        img.thumbnail((240, 180))
        return img
    except Exception as e:
        print(f"[xtion_mapper_gui] Failed to decode snapshot for {uri}: {e}", file=sys.stderr)
        return None


def main():
    # Discover current devices
    uris = run_enumerator()
    if not uris:
        print("[xtion_mapper_gui] No devices found. Plug in Xtions and try again.", file=sys.stderr)
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Xtion Mapper", "No Xtion devices found.\nPlug in cameras and try again.")
        root.destroy()
        return

    existing_mapping = load_mapping()

    uri_roles: dict[str, str] = {}
    for idx, uri in enumerate(uris):
        default_role = f"cam{idx}"
        uri_roles[uri] = existing_mapping.get(uri, default_role)

    suggested_roles = set(existing_mapping.values()) | set(uri_roles.values())
    suggested_roles |= {"front_left", "front_right", "overhead", "hand", "unused"}
    role_options = sorted(suggested_roles)

    root = tk.Tk()
    root.title("Xtion Camera Role Mapper")

    main_frame = ttk.Frame(root, padding=10)
    main_frame.grid(row=0, column=0, sticky="nsew")

    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.columnconfigure(2, weight=1)

    ttk.Label(main_frame, text="URI", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=0, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Role / Name", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=1, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Preview", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=2, sticky="w", padx=5, pady=5
    )

    row_widgets = []  # (uri, role_var, preview_label)
    for row_idx, uri in enumerate(uris, start=1):
        ttk.Label(main_frame, text=uri).grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)

        var = tk.StringVar(value=uri_roles[uri])
        combo = ttk.Combobox(main_frame, textvariable=var, values=role_options)
        combo.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        combo.configure(state="normal")

        preview_label = ttk.Label(main_frame, text="(click Refresh)")
        preview_label.grid(row=row_idx, column=2, sticky="w", padx=5, pady=2)

        row_widgets.append((uri, var, preview_label))

    def update_previews_once():
        for uri, _var, label in row_widgets:
            img = capture_preview(uri)
            if img is None:
                continue
            photo = ImageTk.PhotoImage(img)
            label.configure(image=photo, text="")
            label.image = photo  # keep reference

    def on_save():
        updated_mapping: dict[str, str] = {}
        for uri, var, _label in row_widgets:
            role = var.get().strip()
            if role:
                updated_mapping[uri] = role

        if not updated_mapping:
            if not messagebox.askyesno(
                "Confirm",
                "No roles specified. This will clear the mapping file.\nContinue?"
            ):
                return

        try:
            save_mapping(updated_mapping)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save mapping:\n{e}")
            return

        messagebox.showinfo(
            "Saved",
            "Mapping saved.\n\nNow re-run:\n  python3 -m xtion_bringup.gen_xtion_cameras\nbefore launching multi_xtion."
        )
        root.destroy()

    # Buttons
    button_frame = ttk.Frame(main_frame)
    button_frame.grid(row=len(uris) + 1, column=0, columnspan=3, sticky="e", pady=(10, 0))

    refresh_btn = ttk.Button(button_frame, text="Refresh previews", command=update_previews_once)
    refresh_btn.grid(row=0, column=0, padx=5)

    save_btn = ttk.Button(button_frame, text="Save & Close", command=on_save)
    save_btn.grid(row=0, column=1, padx=5)

    cancel_btn = ttk.Button(button_frame, text="Cancel", command=root.destroy)
    cancel_btn.grid(row=0, column=2, padx=5)

    # Grab one set of previews at startup
    update_previews_once()

    root.mainloop()


if __name__ == "__main__":
    main()
EOF


cd ~/Projects/teleoperation_spot/cpp/xtion_multi
LD_LIBRARY_PATH=~/Projects/teleoperation_spot/cpp/OpenNI2/Bin/x64-Release \
  ./xtion_snapshot 1d27/0601@1/9 /tmp/xtion_test.ppm



cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash
source install/setup.bash

python3 -m xtion_bringup.xtion_mapper_gui



cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash

colcon build --packages-select xtion_bringup
source install/setup.bash
python3 -m xtion_bringup.xtion_mapper_gui


cat << 'EOF' > ~/Projects/teleoperation_spot/system_ws/src/xtion_bringup/xtion_bringup/xtion_mapper_gui.py
#!/usr/bin/env python3
import os
import sys
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox

import yaml
from PIL import Image, ImageTk, ImageOps, ImageEnhance
from ament_index_python.packages import get_package_share_directory

from .gen_xtion_cameras import run_enumerator, load_mapping

HOME = Path.home()
XTION_MULTI_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "xtion_multi"
SNAPSHOT_BIN = XTION_MULTI_DIR / "xtion_snapshot"
OPENNI_LIB_DIR = HOME / "Projects" / "teleoperation_spot" / "cpp" / "OpenNI2" / "Bin" / "x64-Release"


def get_mapping_path() -> Path:
    share_dir = Path(get_package_share_directory("xtion_bringup"))
    config_dir = share_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    return config_dir / "xtion_mapping.yaml"


def save_mapping(uri_to_role: dict[str, str]) -> None:
    mappings_list = [
        {"uri": uri, "role": role}
        for uri, role in uri_to_role.items()
        if role.strip()
    ]
    mapping_path = get_mapping_path()
    data = {"mappings": mappings_list}
    with mapping_path.open("w") as f:
        yaml.safe_dump(data, f, default_flow_style=False)
    print(f"[xtion_mapper_gui] Wrote mapping file {mapping_path}")


def capture_preview(uri: str) -> Image.Image | None:
    """
    Run the C++ xtion_snapshot tool for a given URI and return a PIL Image.
    xtion_snapshot writes a PPM file to disk; we load and lightly prettify it.
    """
    import subprocess
    import traceback

    if not SNAPSHOT_BIN.exists():
        print(f"[xtion_mapper_gui] Snapshot binary not found: {SNAPSHOT_BIN}", file=sys.stderr)
        return None

    cache_dir = HOME / ".cache" / "xtion_previews"
    cache_dir.mkdir(parents=True, exist_ok=True)
    safe_uri = uri.replace("/", "_").replace("@", "_")
    ppm_path = cache_dir / f"{safe_uri}.ppm"

    env = os.environ.copy()
    env["LD_LIBRARY_PATH"] = str(OPENNI_LIB_DIR) + ":" + env.get("LD_LIBRARY_PATH", "")

    try:
        subprocess.run(
            [str(SNAPSHOT_BIN), uri, str(ppm_path)],
            env=env,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
    except subprocess.CalledProcessError:
        print(f"[xtion_mapper_gui] Snapshot failed for {uri}", file=sys.stderr)
        return None
    except Exception:
        traceback.print_exc()
        return None

    if not ppm_path.exists():
        return None

    try:
        img = Image.open(ppm_path)
        img = img.convert("RGB")

        # --- simple "prettify" steps ---

        # 1) Auto-contrast to stretch histogram a little
        img = ImageOps.autocontrast(img, cutoff=1)

        # 2) Slight brightness & contrast boost
        img = ImageEnhance.Brightness(img).enhance(1.1)
        img = ImageEnhance.Contrast(img).enhance(1.1)

        # 3) Resize for GUI
        img.thumbnail((240, 180))
        return img
    except Exception as e:
        print(f"[xtion_mapper_gui] Failed to decode snapshot for {uri}: {e}", file=sys.stderr)
        return None


def main():
    # Discover current devices
    uris = run_enumerator()
    if not uris:
        print("[xtion_mapper_gui] No devices found. Plug in Xtions and try again.", file=sys.stderr)
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror("Xtion Mapper", "No Xtion devices found.\nPlug in cameras and try again.")
        root.destroy()
        return

    existing_mapping = load_mapping()

    uri_roles: dict[str, str] = {}
    for idx, uri in enumerate(uris):
        default_role = f"cam{idx}"
        uri_roles[uri] = existing_mapping.get(uri, default_role)

    suggested_roles = set(existing_mapping.values()) | set(uri_roles.values())
    suggested_roles |= {"front_left", "front_right", "overhead", "hand", "unused"}
    role_options = sorted(suggested_roles)

    root = tk.Tk()
    root.title("Xtion Camera Role Mapper")

    main_frame = ttk.Frame(root, padding=10)
    main_frame.grid(row=0, column=0, sticky="nsew")

    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)
    main_frame.columnconfigure(1, weight=1)
    main_frame.columnconfigure(2, weight=1)

    ttk.Label(main_frame, text="URI", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=0, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Role / Name", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=1, sticky="w", padx=5, pady=5
    )
    ttk.Label(main_frame, text="Preview", font=("TkDefaultFont", 10, "bold")).grid(
        row=0, column=2, sticky="w", padx=5, pady=5
    )

    row_widgets = []  # (uri, role_var, preview_label)
    for row_idx, uri in enumerate(uris, start=1):
        ttk.Label(main_frame, text=uri).grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)

        var = tk.StringVar(value=uri_roles[uri])
        combo = ttk.Combobox(main_frame, textvariable=var, values=role_options)
        combo.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        combo.configure(state="normal")

        preview_label = ttk.Label(main_frame, text="(click Refresh)")
        preview_label.grid(row=row_idx, column=2, sticky="w", padx=5, pady=2)

        row_widgets.append((uri, var, preview_label))

    def update_previews_once():
        for uri, _var, label in row_widgets:
            img = capture_preview(uri)
            if img is None:
                continue
            photo = ImageTk.PhotoImage(img)
            label.configure(image=photo, text="")
            label.image = photo  # keep reference

    def on_save():
        updated_mapping: dict[str, str] = {}
        for uri, var, _label in row_widgets:
            role = var.get().strip()
            if role:
                updated_mapping[uri] = role

        if not updated_mapping:
            if not messagebox.askyesno(
                "Confirm",
                "No roles specified. This will clear the mapping file.\nContinue?"
            ):
                return

        try:
            save_mapping(updated_mapping)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save mapping:\n{e}")
            return

        messagebox.showinfo(
            "Saved",
            "Mapping saved.\n\nNow re-run:\n  python3 -m xtion_bringup.gen_xtion_cameras\nbefore launching multi_xtion."
        )
        root.destroy()

    # Buttons
    button_frame = ttk.Frame(main_frame)
    button_frame.grid(row=len(uris) + 1, column=0, columnspan=3, sticky="e", pady=(10, 0))

    refresh_btn = ttk.Button(button_frame, text="Refresh previews", command=update_previews_once)
    refresh_btn.grid(row=0, column=0, padx=5)

    save_btn = ttk.Button(button_frame, text="Save & Close", command=on_save)
    save_btn.grid(row=0, column=1, padx=5)

    cancel_btn = ttk.Button(button_frame, text="Cancel", command=root.destroy)
    cancel_btn.grid(row=0, column=2, padx=5)

    # Grab one set of previews at startup
    update_previews_once()

    root.mainloop()


if __name__ == "__main__":
    main()
EOF



cd ~/Projects/teleoperation_spot
# 1) Map roles
python3 -m xtion_bringup.xtion_mapper_gui

# 2) Generate runtime config
python3 -m xtion_bringup.gen_xtion_cameras

# 3) Launch cameras
ros2 launch xtion_bringup multi_xtion.launch.py




cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash
source install/setup.bash
python3 -m xtion_bringup.xtion_mapper_gui
python3 -m xtion_bringup.gen_xtion_cameras



sudo nano /etc/udev/rules.d/99-openni-sensor.rules
# ASUS Xtion PRO LIVE
SUBSYSTEM=="usb", ATTR{idVendor}=="1d27", ATTR{idProduct}=="0600", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="1d27", ATTR{idProduct}=="0601", MODE="0666", GROUP="plugdev"

# PrimeSense devices (if needed)
SUBSYSTEM=="usb", ATTR{idVendor}=="045e", ATTR{idProduct}=="02ae", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="045e", ATTR{idProduct}=="02bf", MODE="0666", GROUP="plugdev"

sudo usermod -a -G plugdev $USER


sudo udevadm control --reload-rules
sudo udevadm trigger




cd ~/Projects/teleoperation_spot/system_ws
source /opt/ros/jazzy/setup.bash
source install/setup.bash
python3 -m xtion_bringup.xtion_mapper_gui
python3 -m xtion_bringup.gen_xtion_cameras
ros2 launch xtion_bringup multi_xtion.launch.py


  Resolution Mode Parameters

  Add these parameters to the parameters=[{...}] section in single_asus_xtion.launch.py:

  parameters=[{
      'device_id': device_id,

      # Color/RGB resolution modes:
      'color_mode': '5',   # Options:
                           # '1' = 320x240 @ 30fps
                           # '5' = 640x480 @ 30fps (DEFAULT)
                           # '9' = 1280x1024 @ 30fps (SXGA - max for Xtion)

      # Depth resolution modes:
      'depth_mode': '5',   # Options:
                           # '1' = 320x240 @ 30fps (QVGA)
                           # '5' = 640x480 @ 30fps (VGA - DEFAULT, max for depth)
                           # Note: Depth is limited to 640x480 by hardware

      # IR resolution modes (if using IR instead of RGB):
      'ir_mode': '5',      # Same options as depth_mode
  }],

  Key Points

  - Default: Mode 5 (640x480 @ 30fps) for all streams
  - Max RGB: Mode 9 (1280x1024 @ 30fps)
  - Max Depth: Mode 5 (640x480 @ 30fps) - hardware limitation
  - Lower res options: Mode 1 (320x240) for faster processing/bandwidth

  Example Configurations

  High quality RGB with standard depth:
  'color_mode': '9',   # 1280x1024
  'depth_mode': '5',   # 640x480

  Balanced (current default):
  'color_mode': '5',   # 640x480
  'depth_mode': '5',   # 640x480

  Low bandwidth/fast processing:
  'color_mode': '1',   # 320x240
  'depth_mode': '1',   # 320x240

